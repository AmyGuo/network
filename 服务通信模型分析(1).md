# 服务通信模型分析

标签（空格分隔）： 微服务 rpc

---

# 现有服务通信模型
通信模型：
``` text
       msg            msg
node <-----> broker <-----> node
```

通信节点通过tcp和单个broker(dispatch)相连，并使用type-id通过broker注册到zookeeper中。broker使用type-id标识各个通信节点，并以此转发各个通信节点的消息。同时，通信节点也可以注册和加入使用`group_id`标识的group，broker将group消息转发给属于同一个group的节点。

通过上述描述可见，我们的rpc通信模型是基于消息的，同步通信(下游需要实时在线)模型。支持以下交互方式：
1. 1对1通知 （请求无回复）
2. 1对1同步请求响应（rpc）
3. 1对N发布订阅（group消息）

由于不支持消息存储，不支持以下交互方式：
1. 1对1异步响应(例如，下游上线后再响应)
2. 1对N发布订阅异步响应(同上, 下游上线后再响应)

# 现有通信模型的优缺点

## 优点
 - 内部自研，有源代码
 - 实现简单，满足目前大部分的业务需求

## 缺点
 - 不支持消息存储，也不支持上述两种异步交互模式
 - 发布订阅的实现基于group-id实现，而不是更面向业务的消息主题实现
 - 节点与broker间是单点连接，如果broker不可用，将导致所有与之相连的服务都不可用
 - 通信协议不能保证消息一定必达，更近一步，未实现完整的消息的服务质量：
 1. QoS 0，消息最多分发一次(目前我们支持消息的服务质量)；
 2. QoS 1，消息至少分发一次；
 3. QoS 2, 消息仅分发一次。

# 业务痛点
下面讨论的业务痛点主要基于上述的通信模型缺点以及日常使用展开。
## 业务消息可能丢失
``` text
# 节点间消息传递, 分上下两个半场
            msg                             msg
from_node  -----> broker            broker -----> to_node
           上半场                          下半场

# 基于tcp传递，但是因为node与broker间没有确认和重传，所以broker与node在协议上不能保证消息必达。
# 例如，消息到达broker后，broker崩溃，虽然tcp保证将消息传递到了broker，
# node也认为消息正常发出，但实际上消息在node和broker间是丢失了。
```
目前的实现，有多个场景可能会导致业务消息丢失，常见的有：
1. 目前broker未平滑退出，broker重启或崩溃时，则broker收到但未投递(内存里)的消息丢失。
2. broker与节点间网络故障，broker无法将收到的业务消息投递给下游，收到的消息被丢弃。
3. 下游服务重启升级，因为broker无法存储与落地消息，消息无法送达并被broker主动丢弃。因为消息是投递到具体的单个服务实例，所以无论是单实例服务还是多实例服务，都存在某个实例重启时，投递给该实例的消息无法送达而丢失。

虽然我们大部分的rpc请求都有一个回复，可以确认对方收到了请求消息。但是无论是请求消息，还是回复消息都是有可能丢失的。需要业务方考虑消息丢失的情况，比如在请求超时后重试，以及在回复丢失时保证再次请求幂等。
通知消息(有请求无回复)丢失的情况发送方往往觉察不到消息已丢失。

## 发布订阅在业务上难以使用
业务上存在很多发布订阅模式的使用场景。例如，游戏日志可能用到在多个场景：
1. 运营后台查询
2. 玩家胜率，成就统计等
3. 触发日常活动或任务
4. 其他新增需求
此时，完全可以在游戏服务在游戏结束后，将游戏日志按照标准格式发布到`/game/texas/log`频道，有需求的业务可以订阅并分析游戏日志，而不需要每次有新的游戏日志分析请求时，游戏服务都需要修改以便将日志上报到新的服务。
类似的还有根据比赛结果统计，发奖；玩家的在线状态或金币变化通知等有多个潜在订阅者的场景。

目前一个节点要发布一个消息给多个节点，首先需要将这些节点都注册到一个group，后续可以使用`group_id`发布消息到多个节点。这个发布模式面向的是底层的网络通信，在业务上使用不是太方便：
- `group_id`不方便记忆，消息发布频道维护困难，目前也没有地方可以查询当前的消息频道。
- 无法动态订阅消息。
- `group_id`不能模糊匹配，无法实现将消息发布到匹配某个模式的频道。例如将消息发布到所有的游戏服务器`/gamesvr/*`。
- `group_id`没有层次结构。无法实现将消息频道按照层次组织。例如`/usr/<uid>/session`，`/usr/<uid>/profile`
- 发布消息需要下游在线，无法发布异步的消息。
- 发布订阅同样有丢失消息的可能。

发布订阅模式未能普及使用的其中一个结果就是导致部分业务接口耦合，且实现繁琐，各个业务不能专注于本业务来实现接口。例如上述的游戏日志处理，目前的实现游戏服务往往要依次上报多个服务，且上报的格式与需求方有关。

## 服务无法高可用
消息服务质量无法保证，导致业务消息有丢失的可能。服务升级更新时往往导致业务消息丢失。因为目前所有的内部服务消息都通过broker传递消息，通信无法保证可靠，则业务服务的服务质量必定受到影响。
目前，服务重启更新往往也是我们业务出问题较多的点(包括broker的重启)。

## 无法实现跨服务的事务
因为现在划分了多个业务服务，某个事务可能需要在多个服务间协作实现。例如限定人数的比赛报名扣费。这个场景需要同时修改user服务的金币，报名服务的人数。
跨服务的事务实现，往往需要一个可靠的消息中间件，传递事务的状态，如果无法可靠传递消息，那事务也就无法实现。

## 系统内部通信无缓冲
broker无法存储消息，导致发送消息的上下游之前无缓冲。因此也就无法实现请求的削峰平谷。上游的生成能力和下游的消费能力必须实时匹配。
而且服务无法实现流控，服务无法请求broker临时改变发往服务的请求。例如，对于简单的服务升级，如果可以临时将broker发送给服务的请求降到零，在服务重启更新后再继续接受请求，升级流程可以更简单和平滑。

## API无版本管理
目前，服务提供的方法使用service.method标识，且无版本标识。服务迭代时，由于没有版本标识，请求方无法选择匹配的版本，同一个接口请求的时候，预期的结果不能保持一致，服务的API对于请求方来说不是连续的，这个也降低了服务的高可用。如果服务迭代无法兼容，则要求所有请求方同步升级，完全没有过渡期，如果涉及的服务多，或者多个服务升级，往往鸡飞狗跳。

虽然可以在service.method的method上区分版本，但是层次太低，不利于整体切换以及管理，而且api也不够简单明了。

我们的服务实例使用type和id标识，但是我们在访问服务的时候，关心的服务可以提供资源，应该使用类似URI一样的资源定位符描述我们要访问的资源。type和id可以标识资源，但是不能描述资源。看到type和id并不能让我们知道资源是什么。所以我觉得平常描述服务以及API的时候，应该淡化type和id概念，以面向资源的方式设计API，同时避免通过type和id来描述资源，这样我们的API会更容易理解。

另外，我们也需要更加灵活地将请求转换成broker消息的机制，以便将基于资源的请求，转换成底层的消息并正确路由到对应的服务节点。

## 其他
 - 请求链路跟踪，调用关系，性能分析，日志记录。(消息模型需要提供支持)
 - 常见的调用方式支持，例如多个请求串行执行，多个请求并行执行，并处理局部失败。(rpc实现)
 - rpc调用链超时退出。(rpc实现)
 - rpc客户端断路器等(rpc实现)
 - rpc线程模型同步。目前，无法保证rpc回复的顺序与业务处理的顺序一致。(rpc实现)

# 消息组件优化方案

## 方案一：升级现有broker
修改现有协议，完善以下功能：

 - 消息可靠投递，包括超时重传，确认等。
 - 实现离线消息。
 - 完善发布订阅，提供面向业务的发布订阅接口。
 - 底层转发支持版本管理。

可以参考[MQTT](https://en.wikipedia.org/wiki/MQTT)协议实现。这里需要重复造轮子，有一定的工作量，且需要仔细测试。

## 方案二：使用MQ
我们现在的通信模型是基于消息的异步通信，完全可以使用一个功能更强大的消息中间件代替现有的`dispatch`服务。现有服务主要需要升级消息客户端以便接入新的消息中间件，并实现原有的RPC接口。业务逻辑则一般不用修改。
``` text
node1 <-----> MQ <-----> node2
```

### MQ的可能问题

 - 在保证消息必达的情况下，需要处理重复的消息以及保证幂等。
 - 需要处理无法投递的消息(死信，可能需要人工干预)。
 - 消息可能需要设置过期时间，避免消息延迟到达后，上下文已经过期。
 - 如果消息落地，可能会影响性能。
 - 需要保证消息的顺序。
 - 需要维护MQ代码。
 
## 方案三： 自研broker + MQ
使用自研broker实现同步通信，同时将需要异步通信的消息发送到MQ。使用MQ补足目前异步通信以及发布订阅的短板。

# 参考
[Chris Richardson 微服务系列](http://blog.daocloud.io/microservices-1/)
[到底什么时候该使用MQ？](https://cloud.tencent.com/developer/article/1048677)
[如何保障微服务架构下的数据一致性？](https://cloud.tencent.com/developer/article/1459734)
[API 设计指南](https://cloud.google.com/apis/design?hl=zh-cn)
[MQTT](https://en.wikipedia.org/wiki/MQTT)
